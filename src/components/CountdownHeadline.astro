---
import { t } from "astro-i18n";

import Center from "@components/Center.astro";

interface Props {
  withHeadline?: boolean;
}

const { withHeadline = false } = Astro.props;
---

<my-countdown-headline>
  <Center class="pb-1 lg:pb-2">
    <h3 class="text-center font-serif text-2xl lg:text-3xl">{t("countdown.before")}</h3>
  </Center>

  <Center>
    <div class="grid auto-cols-max grid-flow-col gap-5 text-center">
      <div class="flex flex-col">
        <span class="countdown font-serif text-6xl lg:text-7xl xl:text-8xl">
          <span class="w-16 lg:w-24 xl:w-28" data-id="myCountdownDayValue" style="--value:0;"></span>
        </span>
        <span data-id="myCountdownDayText">{t("countdown.days")}</span>
      </div>
      <div class="flex flex-col">
        <span class="countdown font-serif text-6xl lg:text-7xl xl:text-8xl">
          <span class="w-16 lg:w-24 xl:w-28" data-id="myCountdownHourValue" style="--value:0;"></span>
        </span>
        <span data-id="myCountdownHourText">{t("countdown.hours")}</span>
      </div>
      <div class="flex flex-col">
        <span class="countdown font-serif text-6xl lg:text-7xl xl:text-8xl">
          <span class="w-16 lg:w-24 xl:w-28" data-id="myCountdownMinuteValue" style="--value:0;"></span>
        </span>
        <span data-id="myCountdownMinuteText">{t("countdown.minutes")}</span>
      </div>
      <div class="flex flex-col">
        <span class="countdown font-serif text-6xl lg:text-7xl xl:text-8xl">
          <span class="w-16 lg:w-24 xl:w-28" data-id="myCountdownSecondValue" style="--value:0;"></span>
        </span>
        <span data-id="myCountdownSecondText">{t("countdown.seconds")}</span>
      </div>
    </div>
  </Center>

  {
    withHeadline && (
      <Center class="pt-2 lg:pt-4">
        <h3 data-id="myCountdownHeadline" class="text-center font-serif text-2xl lg:text-3xl" />
      </Center>
    )
  }
</my-countdown-headline>

<script>
  import { t, astroI18n } from "astro-i18n";

  const msgUntil = "... " + t("countdown.until");
  const msgAfter = "... " + t("countdown.after");

  // On November 9, 2025, lunchtime in Belgrade (say 12:00 noon local time CET) is:
  // Belgrade time: 2025-11-09 12:00 CET (UTC+1)
  // UTC time: 2025-11-09 11:00 UTC
  const COUNT_DOWN_DATE = new Date("2025-11-09T11:00:00.000Z").getTime();

  class MyCountdownHeadline extends HTMLElement {
    private intervalId: any = null;

    constructor() {
      super();

      this.setTimeValues();

      this.intervalId = setInterval(this.setTimeValues, 1000);
    }

    /**
     * @override

     * Called each time the element is removed from the document.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#custom_element_lifecycle_callbacks
     */
    disconnectedCallback() {
      clearInterval(this.intervalId);
    }

    private setTimeValues = () => {
      // Find the distance between now and the countdown date
      const distance = COUNT_DOWN_DATE - new Date().getTime();
      const daysDiff = distance / (1000 * 60 * 60 * 24);
      const hoursDiff = (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60);
      const minutesDiff = (distance % (1000 * 60 * 60)) / (1000 * 60);
      const secondsDiff = (distance % (1000 * 60)) / 1000;

      // Time calculations for days, hours, minutes and seconds
      // floor down if positive (time to wedding), ceil up if negative (time from wedding)
      const days = Math.abs(daysDiff >= 0 ? Math.floor(daysDiff) : Math.ceil(daysDiff));
      const hours = Math.abs(hoursDiff >= 0 ? Math.floor(hoursDiff) : Math.ceil(hoursDiff));
      const minutes = Math.abs(minutesDiff >= 0 ? Math.floor(minutesDiff) : Math.ceil(minutesDiff));
      const seconds = Math.abs(secondsDiff >= 0 ? Math.floor(secondsDiff) : Math.ceil(secondsDiff));

      // Display the result in the elements
      this.setValue("myCountdownDayValue", "myCountdownDayText", days, "countdown.days");
      this.setValue("myCountdownHourValue", "myCountdownHourText", hours, "countdown.hours");
      this.setValue("myCountdownMinuteValue", "myCountdownMinuteText", minutes, "countdown.minutes");
      this.setValue("myCountdownSecondValue", "myCountdownSecondText", seconds, "countdown.seconds");

      // Display the headline text if present
      const myCountdownHeadline = this.querySelector<HTMLHeadingElement>('[data-id="myCountdownHeadline"]');
      if (myCountdownHeadline != null) {
        myCountdownHeadline.innerText = distance > 0 ? msgUntil : msgAfter;
      }
    };

    private setValue = (valueDataId: string, textDataId: string, value: number, translation: Translation) => {
      this.querySelector<HTMLSpanElement>(`[data-id="${valueDataId}"]`)?.style.setProperty("--value", String(value));
      const daysTextEl = this.querySelector<HTMLSpanElement>(`[data-id="${textDataId}"]`);
      if (daysTextEl) {
        if (astroI18n.locale === "ru" || astroI18n.locale === "sr") {
          // Russian and Serbian have complex plural forms, so we let the i18n library handle it
          let count = 0;
          const restOf100 = value % 100;
          if (restOf100 === 11 || restOf100 === 12 || restOf100 === 13 || restOf100 === 14) {
            count = 0; // many
          } else {
            const restOf10 = value % 10;
            if (restOf10 === 1) {
              count = 1; // one
            } else if (restOf10 === 2 || restOf10 === 3 || restOf10 === 4) {
              count = 2; // few
            } else {
              count = 0; // many
            }
          }

          daysTextEl.innerText = t(translation, { count });
        } else {
          // Other languages (like English and German) have simple plural forms, so we can use our custom logic
          daysTextEl.innerText = t(translation, { count: value });
        }
      }
    };
  }

  // Tell the browser to use our AstroHeart class for <astro-heart> elements.
  customElements.define("my-countdown-headline", MyCountdownHeadline);
</script>
